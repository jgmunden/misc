# Plotting fishing time using gs
gs = scanmar.db( DS="bottom.contact", p=p)  # bring in estimates of bottom contact times from scanmar
filtered = scanmar.db( DS="scanmar.filtered",  p=p )  # bring in estimates of bottom contact times from scanmar
load("master.updated.RData")

# add year
gs$year = substring(as.character(gs$id), 4,7)
# subset by years
gs=gs[which(gs$year %in% 2004:2014), ]

# fishing time generated by our algorithms
str(gs)
gs$bottom_duration = gs$bottom_duration/60
summary(gs$bottom_duration)
max_num = max(gs$bottom_duration)
hist(gs$bottom_duration, main = "Fishing Time Distribution", xlab="Fishing Time (min)", ylab="Frequency", 
     col="light blue", border="blue3")
mean(gs$bottom_duration, na.rm=TRUE)
max(gs$bottom_duration, na.rm=TRUE)
min(gs$bottom_duration, na.rm=TRUE)

text(35, 600, "Mean = 27.78 min")
text(15, 170, "Min = 15.26 min")
text(43, 100, "Max = 44.61 min")


# fishing time generataed by bridge
gs$gstime = difftime(gs$edate, gs$sdate, units= "mins")
head(gs$gstime)
summary(gs$gstime)

x = which(gs$gstime < 0)
gs = gs[-x,]


hist(as.numeric(gs$gstime), breaks=100, col=c("green"), xlab="Fishing time determined by gsinf", main= "", border = "forest green")
abline(v=30, col="darkblue", lwd=c(3.5,3.5))
mean(gs$gstime, na.rm=TRUE)
text(50, 3000, "Mean = 69.46 min")

# Wingspread
hist(filteredlm$wingspread, main = "Wingspread Frequencies", xlab="Wingspread (m)", ylab="Frequency", 
     col="light blue", border="navy")
mean(filteredlm$wingspread, na.rm=TRUE)
text(16.5, 350000, "Mean = 14.75 m")
abline(v=12.5, col= "red", lwd=c(2.5,2.5))
legend(18.5, 280000, c("standard = 12.5m"), lty=c(1,1), 
       lwd=c(2.5,2.5), col=c("red"))

# Doorspread
hist(filteredlm$doorspread, main = "Doorspread Frequencies", xlab="Doorspread (m)", ylab="Frequency", 
     col="light green", border="green3")
mean(filteredlm$doorspread, na.rm=TRUE)
text(65, 250000, "Mean = 55.81 m")

# headline
hist(filteredlm$opening, main = "Headline Height Frequencies", xlab="Headline Height (m)", ylab="Frequency", 
     col="orange", border="orange3")
mean(filteredlm$opening, na.rm=TRUE)
text(4.3, 590000, "Mean = 3.28 m")

# depth
hist(filteredlm$depth, main = "Depth Frequencies", xlab="Depth (m)", ylab="Frequency", 
     col="grey", border="grey3", breaks="fd")
mean(filteredlm$depth, na.rm=TRUE)
text(170, 800000, "Mean = 126.92 m")


# relationship between fishing time and depth
plot(bottom_duration~bottom_depth, gs, xlim=c(0, 600), xlab="Bottom depth (m)", ylab="Fishing time (min)", pch=19, cex=0.5)
# Trying to sovle the fishing time bi-modal mystery
# all years, depths..not sure why?
# Perhaps it could be because we haven't applied the std. filter 
# Caused by poor bottom estimates?
points(bottom_duration~bottom_depth, gs.fail, pch=19, cex=0.5, col= "red")
i = which(gs$bc0.sd > 30)
p = which(gs$bc1.sd > 30)
gs.fail = gs[-i, -p] 
# Nope!
legend(500, 40, c("Accepted", "Rejected"), lty=c(1,1), 
       lwd=c(2.5,2.5), col=c("black", "red"))


# latitude and longitude with fishing time
loadfunctions("polygons")
require(PBSmapping)
land = importPolys(polygon.ecomod("worldLR.ll"))

plotMap(land, xlim=c(-75, -55), ylim=c(35, 50),density=0)
points(latitude~longitude, filtered, pch=19, cex=0.4, col="red", xlim=c(-75, -55), ylim=c(35, 50))

# put bottom_duration in mins
gs$bottom_duration = gs$bottom_duration/60
# establish range of fishing time (< 20 mins)
i = gs[which((gs$bottom_duration < 20)), ]
list = i$id
flm = filteredlm[which((filteredlm$id %in% list)), ]
length(unique(flm$id))
points(latitude~longitude, flm, col="red", pch=19, cex=0.5)
legend(x="bottomleft", c("Sets with fishing time < 20 min"),
       col=c("red"), pch =(19))

summary(gs$bottom_duration)
summary(gs)

# latitude and longitude 
loadfunctions("polygons")
require(PBSmapping)
land = importPolys(polygon.ecomod("worldLR.ll"))

plotMap(land, xlim=c(-75, -55), ylim=c(35, 50),density=0)
test=gs[which(gs$year == 2014), ]
testy=master[which(master$year == 2014), ]
points(latitude~longitude, testy, pch=19, col="red")
points(lat~lon, test, pch=19, col="grey")

# put bottom_duration in mins, separate by less than 20 min and more
gs$bottom_duration = gs$bottom_duration/60
i = gs[which((gs$bottom_duration < 20)), ]
list = i$id
flm = filteredlm[which((filteredlm$id %in% list)), ]
length(unique(flm$id))
points(latitude~longitude, flm, col="blue", pch=19, cex=0.4)


# separate 

i = gs[which((gs$bottom_depth < 600)), ]
list = i$id
flm = filteredlm[which((filteredlm$id %in% list)), ]
length(unique(flm$id))
points(latitude~longitude, flm, col="red", pch=19, cex=0.4)

i = gs[which((gs$bottom_depth < 400)), ]
list = i$id
flm = filteredlm[which((filteredlm$id %in% list)), ]
length(unique(flm$id))
points(latitude~longitude, flm, col="green", pch=19, cex=0.4)

i = gs[which((gs$bottom_depth < 200)), ]
list = i$id
flm = filteredlm[which((filteredlm$id %in% list)), ]
length(unique(flm$id))
points(latitude~longitude, flm, col="yellow", pch=19, cex=0.4)

i = gs[which((gs$bottom_depth < 100)), ]
list = i$id
flm = filteredlm[which((filteredlm$id %in% list)), ]
length(unique(flm$id))
points(latitude~longitude, flm, col="violet", pch=19, cex=0.4)

i = gs[which((gs$bottom_depth < 50)), ]
list = i$id
flm = filteredlm[which((filteredlm$id %in% list)), ]
length(unique(flm$id))
points(latitude~longitude, flm, col="blue", pch=19, cex=0.4)


legend(x="bottomleft", c("< 600", "< 400", "< 200", "< 100", "< 50"), col=c("red", "green", "yellow", "violet", "blue"), pch =19)










#bathmetry
i200 = read.table( polygon.ecomod("d200.ll"), as.is=TRUE, colClasses="numeric", skip=1 )
names(i200) = c("PID", "SID", "POS", "X", "Y")
i200 = i200 [ which( is.finite( rowSums( i200))), ]
ii = as.PolySet( i200)
addPolys(ii, border="khaki", projection=1)


for ( i in unique( ii$SID )) {
  j = which( ii$SID==i)
  if (length( j) > 1) {
    jj = ii[j,] 
    addPolys(jj, border="khaki")
  }
}




borders= read.csv(file=file.path(wd,"Management_Areas","Fisheries","areaborders.csv"), head=T, sep=",")
b=borders[which(borders$area==area),]


# read in shapefiles
#--------------------------------------
land= importShapefile(file.path(wd,"Basemaps","Terrestrial","landmass_region"))
coast=importShapefile(file.path(wd,"Basemaps","Marine","Coastline","coastline_polyline"))

#Overlay land and coastline such that any bad data (on land) is hidden
addPolys(land, col="khaki", border="khaki")
addLines(coast, col="black")
abline(h=b$slat, lwd=3)
abline(h=b$nlat, lwd=3)
abline(v=-b$wlon, lwd=3)
abline(v=-b$elon, lwd=3)



---------------------------------------------------------------------------------------------  
  # Trying to match up times in GS, Scanmar and our bc estimates
  
  # Need to make a new d.f. to figure out timestamps
  i=which(!is.finite(gs$bc0.datetime))
gs = gs[ -i, ]
r.samp=gs[sample(1:nrow(gs), 10, replace=FALSE),]
listid = r.samp$id

gs.time = data.frame(r.samp$id, r.samp$sdate, r.samp$edate, r.samp$bc0.datetime, r.samp$ bc1.datetime)
head(gs.time)
colnames(gs.time) =  c("id", "sdate", "edate", "bc0", "bc1")
str(gs.time) 
write.table(gs.time, file= "gs.time.csv", sep = ",", quote=FALSE, row.names=FALSE, col.names=TRUE)

# Make a for loop, plotting raw data, then fishing time by winches and by our methods
i = which(gs$bottom_duration < 20*60)

allids = gs[i,]

allids=gs[sample(1:nrow(gs), 10, replace=FALSE),]$id

for (id in allids){
  test=which(master$id==id)
  test.g = which(gs$id==id)
  i=master[test,]
  j=gs[test.g,]
  d=range(i$depth, na.rm=TRUE)
  if(any(is.finite(d))) {
    plot(depth~timestamp,i, pch=19, lwd = 1, cex=0.6, main =  "Depth", sub=id)
    }
    abline(v=(j$bc0.datetime), col="blue", lwd = 2.5)
    abline(v=(j$bc1.datetime), col="blue", lwd = 2.5)
    abline(v=(j$sdate), col="red", lty="dotted", lwd = 2)
    abline(v=(j$edate), col="red", lty="dotted", lwd = 2)
    legend("bottomleft", c("Computed", "Winch derived"), lty = c(1,1), lwd = c(2.5, 2.5), col=c("blue", "red"))
  }


# determing when edate was not recorded
ed = which(!is.finite(gs$edate))
ied = gs[ed,]
head(ied)

gez=ied[which(ied$timestamp < "2003-02-24 05:05:00"), ]
hist(gez$timestamp, breaks=20, col="light green", freq = TRUE, main = "Sets with no edate", xlab="year")

#QC gs to see if the plots which only have one estimate do in facts  havea start and end time
mav=gs[which(gs$id == "TEL2004530.9"), ]
head(mav$timestamp)
mav$sdate
mav$edate
abs(mav$edate - mav$sdate)

# time differences: 1.5 hrs, 1.3 hrs, 


# individual sets from master
test=master[which(master$id == "TEL2005605.53"), ]
min(test$timestamp)
max(test$timestamp)
hist(ied$timestamp, breaks = 20, main= "missing edate", xlab="year", col="light blue")

# Plot fishing time with winches vs fishing time with our methods
# Take random sample of ids
r.samp=filteredlm[sample(1:nrow(filteredlm), 10, replace=FALSE),]
r.samp$id

subgs = gs[which((gs$id == "NED2012002.118")), ]
submaster = master[which((master$id == "NED2012002.118")), ]
submaster$timestamp2 = force_tz(submaster$timestamp, tzone = "UTC")

[1] "NED2013022.44"  "NED2010027.129" "NED2012002.118" "NED2013028.176" "NED2009027.105" "NED2009027.24"  "NED2006001.72"  "NED2010027.208"
[9] "NED2009027.169" "NED2010027.155"

d=range(submaster$depth, na.rm=TRUE)
plot(depth~timestamp,submaster, type = "p", lwd = 1, main =  "Trawl Profile", sub=id, ylim=c(d[2], d[1]))

# Min and max time recorded by Scanmar
min(submaster$timestamp)
max(submaster$timestamp)

# Force GSINF times to match Scanmar
dated = force_tz(subgs$sdate, tzone = "Canada/Halifax")
dated
abline(v = dated, col = "red")
stdate = dated - (3*60*60)
abline(v=stdate, col="red")

datedd = force_tz(subgs$edate, tzone = "UTC")
datedd
abline(v = datedd, col = "red")
endate = datedd + (3*60*60)
abline(v=endate, col="red")

# Force our calculated bottom times to match Scanmar
bc = force_tz(subgs$bc0.datetime, tzone = "UTC")
bc0 = bc + 60*60
abline(v=bc0, col="blue")

bc = force_tz(subgs$bc1.datetime, tzone = "UTC")
bc1 = bc + 60*60
abline(v=bc1, col="blue")

legend(ymd_hms("2010-08-06 12:30:00"),40, c("Fishing time determined by the winch"), lty=c(1,1), lwd=c(2.5,2.5), col=c("red"))
legend(ymd_hms("2010-08-06 12:40:00"),40, c("Winch", "Algorithm"), lty=c(1,1), lwd=c(2.5,2.5), col=c("red","blue"))


# Comparing bottom time estimates, ours versus GSinf
gs$gsbt = as.numeric((gs$edate - gs$sdate)/60)
gs$bottom_duration = gs$bottom_duration/60
gs$diff = abs(gs$gsbt - gs$bottom_duration)

plot(gs$diff)
hist(gs$diff)

summary(gs$bottom_duration)
summary(gs$gsbt)

------------------------------------------------------------------------------------------------------------------------------------
# Make a for loop, plotting those sets where only 1 or 2 fishing time estimates were produced for fishing time start or end
  
# Fishing time start
bc = gs[which(gs$bc1.n == 2 | gs$bc0.n == 2), ]

# Gne
allids=unique(bc$id)
i=sample(1:length(allids),)
allids=allids[i]

for (id in allids){
  test=which(master$id==id)
  test.g = which(gs$id==id)
  i=master[test,]
  j=gs[test.g,]
  d=range(i$depth, na.rm=TRUE)
  if(any(is.finite(d))) {
    plot(depth~timestamp,i, pch=19, lwd = 1, cex=0.6, sub=id,  ylim=c(d[2], d[1]))
    
  }
  abline(v=(j$bc0.datetime), col="blue", lwd = 2.5)
  abline(v=(j$bc1.datetime), col="blue", lwd = 2.5)
}

# check ids
id = "NED2013022.192"
test = gs[which(gs$id == id),]
test
